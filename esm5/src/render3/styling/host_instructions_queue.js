import { DEFAULT_TEMPLATE_DIRECTIVE_INDEX } from '../styling/shared';
/*
 * This file contains the logic to defer all hostBindings-related styling code to run
 * at a later point, instead of immediately (as is the case with how template-level
 * styling instructions are run).
 *
 * Certain styling instructions, present within directives, components and sub-classed
 * directives, are evaluated at different points (depending on priority) and will therefore
 * not be applied to the styling context of an element immediately. They are instead
 * designed to be applied just before styling is applied to an element.
 *
 * (The priority for when certain host-related styling operations are executed is discussed
 * more within `interfaces/styling.ts`.)
 */
export function registerHostDirective(context, directiveIndex) {
    var buffer = context[8 /* HostInstructionsQueue */];
    if (!buffer) {
        buffer = context[8 /* HostInstructionsQueue */] = [DEFAULT_TEMPLATE_DIRECTIVE_INDEX];
    }
    buffer[0 /* LastRegisteredDirectiveIndexPosition */] = directiveIndex;
}
/**
 * Queues a styling instruction to be run just before `renderStyling()` is executed.
 */
export function enqueueHostInstruction(context, priority, instructionFn, instructionFnArgs) {
    var buffer = context[8 /* HostInstructionsQueue */];
    // Buffer may be null if host element is a template node. In this case, just ignore the style.
    if (buffer != null) {
        var index = findNextInsertionIndex(buffer, priority);
        buffer.splice(index, 0, priority, instructionFn, instructionFnArgs);
    }
}
/**
 * Figures out where exactly to to insert the next host instruction queue entry.
 */
function findNextInsertionIndex(buffer, priority) {
    for (var i = 1 /* ValuesStartPosition */; i < buffer.length; i += 3 /* Size */) {
        var p = buffer[i + 0 /* DirectiveIndexOffset */];
        if (p > priority) {
            return i;
        }
    }
    return buffer.length;
}
/**
 * Iterates through the host instructions queue (if present within the provided
 * context) and executes each queued instruction entry.
 */
export function flushQueue(context) {
    var buffer = context[8 /* HostInstructionsQueue */];
    if (buffer) {
        for (var i = 1 /* ValuesStartPosition */; i < buffer.length; i += 3 /* Size */) {
            var fn = buffer[i + 1 /* InstructionFnOffset */];
            var args = buffer[i + 2 /* ParamsOffset */];
            fn.apply(this, args);
        }
        buffer.length = 1 /* ValuesStartPosition */;
    }
}
/**
 * Determines whether or not to allow the host instructions queue to be flushed or not.
 *
 * Because the hostBindings function code is unaware of the presence of other host bindings
 * (as well as the template function) then styling is evaluated multiple times per element.
 * To prevent style and class values from being applied to the element multiple times, a
 * flush is only allowed when the last directive (the directive that was registered into
 * the styling context) attempts to render its styling.
 */
export function allowFlush(context, directiveIndex) {
    var buffer = context[8 /* HostInstructionsQueue */];
    if (buffer) {
        return buffer[0 /* LastRegisteredDirectiveIndexPosition */] ===
            directiveIndex;
    }
    return true;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaG9zdF9pbnN0cnVjdGlvbnNfcXVldWUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9wYWNrYWdlcy9jb3JlL3NyYy9yZW5kZXIzL3N0eWxpbmcvaG9zdF9pbnN0cnVjdGlvbnNfcXVldWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBUUEsT0FBTyxFQUFDLGdDQUFnQyxFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFFbkU7Ozs7Ozs7Ozs7OztHQVlHO0FBRUgsTUFBTSxVQUFVLHFCQUFxQixDQUFDLE9BQXVCLEVBQUUsY0FBc0I7SUFDbkYsSUFBSSxNQUFNLEdBQUcsT0FBTywrQkFBb0MsQ0FBQztJQUN6RCxJQUFJLENBQUMsTUFBTSxFQUFFO1FBQ1gsTUFBTSxHQUFHLE9BQU8sK0JBQW9DLEdBQUcsQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDO0tBQzNGO0lBQ0QsTUFBTSw4Q0FBaUUsR0FBRyxjQUFjLENBQUM7QUFDM0YsQ0FBQztBQUVEOztHQUVHO0FBQ0gsTUFBTSxVQUFVLHNCQUFzQixDQUNsQyxPQUF1QixFQUFFLFFBQWdCLEVBQUUsYUFBZ0IsRUFBRSxpQkFBOEI7SUFDN0YsSUFBTSxNQUFNLEdBQStCLE9BQU8sK0JBQW9DLENBQUM7SUFDdkYsOEZBQThGO0lBQzlGLElBQUksTUFBTSxJQUFJLElBQUksRUFBRTtRQUNsQixJQUFNLEtBQUssR0FBRyxzQkFBc0IsQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDdkQsTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLFFBQVEsRUFBRSxhQUFhLEVBQUUsaUJBQWlCLENBQUMsQ0FBQztLQUNyRTtBQUNILENBQUM7QUFFRDs7R0FFRztBQUNILFNBQVMsc0JBQXNCLENBQUMsTUFBNkIsRUFBRSxRQUFnQjtJQUM3RSxLQUFLLElBQUksQ0FBQyw4QkFBaUQsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFDekUsQ0FBQyxnQkFBbUMsRUFBRTtRQUN6QyxJQUFNLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQywrQkFBa0QsQ0FBVyxDQUFDO1FBQ2hGLElBQUksQ0FBQyxHQUFHLFFBQVEsRUFBRTtZQUNoQixPQUFPLENBQUMsQ0FBQztTQUNWO0tBQ0Y7SUFDRCxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUM7QUFDdkIsQ0FBQztBQUVEOzs7R0FHRztBQUNILE1BQU0sVUFBVSxVQUFVLENBQWdCLE9BQXVCO0lBQy9ELElBQU0sTUFBTSxHQUFHLE9BQU8sK0JBQW9DLENBQUM7SUFDM0QsSUFBSSxNQUFNLEVBQUU7UUFDVixLQUFLLElBQUksQ0FBQyw4QkFBaUQsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFDekUsQ0FBQyxnQkFBbUMsRUFBRTtZQUN6QyxJQUFNLEVBQUUsR0FBRyxNQUFNLENBQUMsQ0FBQyw4QkFBaUQsQ0FBYSxDQUFDO1lBQ2xGLElBQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxDQUFDLHVCQUEwQyxDQUFVLENBQUM7WUFDMUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDdEI7UUFDRCxNQUFNLENBQUMsTUFBTSw4QkFBaUQsQ0FBQztLQUNoRTtBQUNILENBQUM7QUFFRDs7Ozs7Ozs7R0FRRztBQUNILE1BQU0sVUFBVSxVQUFVLENBQUMsT0FBdUIsRUFBRSxjQUFzQjtJQUN4RSxJQUFNLE1BQU0sR0FBRyxPQUFPLCtCQUFvQyxDQUFDO0lBQzNELElBQUksTUFBTSxFQUFFO1FBQ1YsT0FBTyxNQUFNLDhDQUFpRTtZQUMxRSxjQUFjLENBQUM7S0FDcEI7SUFDRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiogQGxpY2Vuc2VcbiogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4qXG4qIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4qIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiovXG5pbXBvcnQge0hvc3RJbnN0cnVjdGlvbnNRdWV1ZSwgSG9zdEluc3RydWN0aW9uc1F1ZXVlSW5kZXgsIFN0eWxpbmdDb250ZXh0LCBTdHlsaW5nSW5kZXh9IGZyb20gJy4uL2ludGVyZmFjZXMvc3R5bGluZyc7XG5pbXBvcnQge0RFRkFVTFRfVEVNUExBVEVfRElSRUNUSVZFX0lOREVYfSBmcm9tICcuLi9zdHlsaW5nL3NoYXJlZCc7XG5cbi8qXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgdGhlIGxvZ2ljIHRvIGRlZmVyIGFsbCBob3N0QmluZGluZ3MtcmVsYXRlZCBzdHlsaW5nIGNvZGUgdG8gcnVuXG4gKiBhdCBhIGxhdGVyIHBvaW50LCBpbnN0ZWFkIG9mIGltbWVkaWF0ZWx5IChhcyBpcyB0aGUgY2FzZSB3aXRoIGhvdyB0ZW1wbGF0ZS1sZXZlbFxuICogc3R5bGluZyBpbnN0cnVjdGlvbnMgYXJlIHJ1bikuXG4gKlxuICogQ2VydGFpbiBzdHlsaW5nIGluc3RydWN0aW9ucywgcHJlc2VudCB3aXRoaW4gZGlyZWN0aXZlcywgY29tcG9uZW50cyBhbmQgc3ViLWNsYXNzZWRcbiAqIGRpcmVjdGl2ZXMsIGFyZSBldmFsdWF0ZWQgYXQgZGlmZmVyZW50IHBvaW50cyAoZGVwZW5kaW5nIG9uIHByaW9yaXR5KSBhbmQgd2lsbCB0aGVyZWZvcmVcbiAqIG5vdCBiZSBhcHBsaWVkIHRvIHRoZSBzdHlsaW5nIGNvbnRleHQgb2YgYW4gZWxlbWVudCBpbW1lZGlhdGVseS4gVGhleSBhcmUgaW5zdGVhZFxuICogZGVzaWduZWQgdG8gYmUgYXBwbGllZCBqdXN0IGJlZm9yZSBzdHlsaW5nIGlzIGFwcGxpZWQgdG8gYW4gZWxlbWVudC5cbiAqXG4gKiAoVGhlIHByaW9yaXR5IGZvciB3aGVuIGNlcnRhaW4gaG9zdC1yZWxhdGVkIHN0eWxpbmcgb3BlcmF0aW9ucyBhcmUgZXhlY3V0ZWQgaXMgZGlzY3Vzc2VkXG4gKiBtb3JlIHdpdGhpbiBgaW50ZXJmYWNlcy9zdHlsaW5nLnRzYC4pXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVySG9zdERpcmVjdGl2ZShjb250ZXh0OiBTdHlsaW5nQ29udGV4dCwgZGlyZWN0aXZlSW5kZXg6IG51bWJlcikge1xuICBsZXQgYnVmZmVyID0gY29udGV4dFtTdHlsaW5nSW5kZXguSG9zdEluc3RydWN0aW9uc1F1ZXVlXTtcbiAgaWYgKCFidWZmZXIpIHtcbiAgICBidWZmZXIgPSBjb250ZXh0W1N0eWxpbmdJbmRleC5Ib3N0SW5zdHJ1Y3Rpb25zUXVldWVdID0gW0RFRkFVTFRfVEVNUExBVEVfRElSRUNUSVZFX0lOREVYXTtcbiAgfVxuICBidWZmZXJbSG9zdEluc3RydWN0aW9uc1F1ZXVlSW5kZXguTGFzdFJlZ2lzdGVyZWREaXJlY3RpdmVJbmRleFBvc2l0aW9uXSA9IGRpcmVjdGl2ZUluZGV4O1xufVxuXG4vKipcbiAqIFF1ZXVlcyBhIHN0eWxpbmcgaW5zdHJ1Y3Rpb24gdG8gYmUgcnVuIGp1c3QgYmVmb3JlIGByZW5kZXJTdHlsaW5nKClgIGlzIGV4ZWN1dGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5xdWV1ZUhvc3RJbnN0cnVjdGlvbjxUIGV4dGVuZHMgRnVuY3Rpb24+KFxuICAgIGNvbnRleHQ6IFN0eWxpbmdDb250ZXh0LCBwcmlvcml0eTogbnVtYmVyLCBpbnN0cnVjdGlvbkZuOiBULCBpbnN0cnVjdGlvbkZuQXJnczogUGFyYW1zT2Y8VD4pIHtcbiAgY29uc3QgYnVmZmVyOiBIb3N0SW5zdHJ1Y3Rpb25zUXVldWV8bnVsbCA9IGNvbnRleHRbU3R5bGluZ0luZGV4Lkhvc3RJbnN0cnVjdGlvbnNRdWV1ZV07XG4gIC8vIEJ1ZmZlciBtYXkgYmUgbnVsbCBpZiBob3N0IGVsZW1lbnQgaXMgYSB0ZW1wbGF0ZSBub2RlLiBJbiB0aGlzIGNhc2UsIGp1c3QgaWdub3JlIHRoZSBzdHlsZS5cbiAgaWYgKGJ1ZmZlciAhPSBudWxsKSB7XG4gICAgY29uc3QgaW5kZXggPSBmaW5kTmV4dEluc2VydGlvbkluZGV4KGJ1ZmZlciwgcHJpb3JpdHkpO1xuICAgIGJ1ZmZlci5zcGxpY2UoaW5kZXgsIDAsIHByaW9yaXR5LCBpbnN0cnVjdGlvbkZuLCBpbnN0cnVjdGlvbkZuQXJncyk7XG4gIH1cbn1cblxuLyoqXG4gKiBGaWd1cmVzIG91dCB3aGVyZSBleGFjdGx5IHRvIHRvIGluc2VydCB0aGUgbmV4dCBob3N0IGluc3RydWN0aW9uIHF1ZXVlIGVudHJ5LlxuICovXG5mdW5jdGlvbiBmaW5kTmV4dEluc2VydGlvbkluZGV4KGJ1ZmZlcjogSG9zdEluc3RydWN0aW9uc1F1ZXVlLCBwcmlvcml0eTogbnVtYmVyKTogbnVtYmVyIHtcbiAgZm9yIChsZXQgaSA9IEhvc3RJbnN0cnVjdGlvbnNRdWV1ZUluZGV4LlZhbHVlc1N0YXJ0UG9zaXRpb247IGkgPCBidWZmZXIubGVuZ3RoO1xuICAgICAgIGkgKz0gSG9zdEluc3RydWN0aW9uc1F1ZXVlSW5kZXguU2l6ZSkge1xuICAgIGNvbnN0IHAgPSBidWZmZXJbaSArIEhvc3RJbnN0cnVjdGlvbnNRdWV1ZUluZGV4LkRpcmVjdGl2ZUluZGV4T2Zmc2V0XSBhcyBudW1iZXI7XG4gICAgaWYgKHAgPiBwcmlvcml0eSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiBidWZmZXIubGVuZ3RoO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggdGhlIGhvc3QgaW5zdHJ1Y3Rpb25zIHF1ZXVlIChpZiBwcmVzZW50IHdpdGhpbiB0aGUgcHJvdmlkZWRcbiAqIGNvbnRleHQpIGFuZCBleGVjdXRlcyBlYWNoIHF1ZXVlZCBpbnN0cnVjdGlvbiBlbnRyeS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsdXNoUXVldWUodGhpczogdW5rbm93biwgY29udGV4dDogU3R5bGluZ0NvbnRleHQpOiB2b2lkIHtcbiAgY29uc3QgYnVmZmVyID0gY29udGV4dFtTdHlsaW5nSW5kZXguSG9zdEluc3RydWN0aW9uc1F1ZXVlXTtcbiAgaWYgKGJ1ZmZlcikge1xuICAgIGZvciAobGV0IGkgPSBIb3N0SW5zdHJ1Y3Rpb25zUXVldWVJbmRleC5WYWx1ZXNTdGFydFBvc2l0aW9uOyBpIDwgYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgIGkgKz0gSG9zdEluc3RydWN0aW9uc1F1ZXVlSW5kZXguU2l6ZSkge1xuICAgICAgY29uc3QgZm4gPSBidWZmZXJbaSArIEhvc3RJbnN0cnVjdGlvbnNRdWV1ZUluZGV4Lkluc3RydWN0aW9uRm5PZmZzZXRdIGFzIEZ1bmN0aW9uO1xuICAgICAgY29uc3QgYXJncyA9IGJ1ZmZlcltpICsgSG9zdEluc3RydWN0aW9uc1F1ZXVlSW5kZXguUGFyYW1zT2Zmc2V0XSBhcyBhbnlbXTtcbiAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICBidWZmZXIubGVuZ3RoID0gSG9zdEluc3RydWN0aW9uc1F1ZXVlSW5kZXguVmFsdWVzU3RhcnRQb3NpdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdG8gYWxsb3cgdGhlIGhvc3QgaW5zdHJ1Y3Rpb25zIHF1ZXVlIHRvIGJlIGZsdXNoZWQgb3Igbm90LlxuICpcbiAqIEJlY2F1c2UgdGhlIGhvc3RCaW5kaW5ncyBmdW5jdGlvbiBjb2RlIGlzIHVuYXdhcmUgb2YgdGhlIHByZXNlbmNlIG9mIG90aGVyIGhvc3QgYmluZGluZ3NcbiAqIChhcyB3ZWxsIGFzIHRoZSB0ZW1wbGF0ZSBmdW5jdGlvbikgdGhlbiBzdHlsaW5nIGlzIGV2YWx1YXRlZCBtdWx0aXBsZSB0aW1lcyBwZXIgZWxlbWVudC5cbiAqIFRvIHByZXZlbnQgc3R5bGUgYW5kIGNsYXNzIHZhbHVlcyBmcm9tIGJlaW5nIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQgbXVsdGlwbGUgdGltZXMsIGFcbiAqIGZsdXNoIGlzIG9ubHkgYWxsb3dlZCB3aGVuIHRoZSBsYXN0IGRpcmVjdGl2ZSAodGhlIGRpcmVjdGl2ZSB0aGF0IHdhcyByZWdpc3RlcmVkIGludG9cbiAqIHRoZSBzdHlsaW5nIGNvbnRleHQpIGF0dGVtcHRzIHRvIHJlbmRlciBpdHMgc3R5bGluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFsbG93Rmx1c2goY29udGV4dDogU3R5bGluZ0NvbnRleHQsIGRpcmVjdGl2ZUluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcbiAgY29uc3QgYnVmZmVyID0gY29udGV4dFtTdHlsaW5nSW5kZXguSG9zdEluc3RydWN0aW9uc1F1ZXVlXTtcbiAgaWYgKGJ1ZmZlcikge1xuICAgIHJldHVybiBidWZmZXJbSG9zdEluc3RydWN0aW9uc1F1ZXVlSW5kZXguTGFzdFJlZ2lzdGVyZWREaXJlY3RpdmVJbmRleFBvc2l0aW9uXSA9PT1cbiAgICAgICAgZGlyZWN0aXZlSW5kZXg7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogSW5mZXJzIHRoZSBwYXJhbWV0ZXJzIG9mIGEgZ2l2ZW4gZnVuY3Rpb24gaW50byBhIHR5cGVkIGFycmF5LlxuICovXG5leHBvcnQgdHlwZSBQYXJhbXNPZjxUPiA9IFQgZXh0ZW5kcyguLi5hcmdzOiBpbmZlciBUKSA9PiBhbnkgPyBUIDogbmV2ZXI7XG4iXX0=