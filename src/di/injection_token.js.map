{"version":3,"sources":["../../../../../modules/@angular/core/src/di/injection_token.ts"],"names":[],"mappings":"AACA;;;;;;;;;;;;;;;;;;;;;;GAsBG;AACH;IACA;;OAEG;IACH,YAIwB,KAAO;QAAP,UAAA,GAAA,KAAA,CAAO;IAAO,CAAA;IAHtC;;OAEG;IACH,QAEG,KAAoB,MAAA,CAAO,SAAA,IAAU,CAAI,KAAC,EAAK,CAAE,CAAC,CAAA;AADrD,CAAC;AAED;IACA,gBAAgB;IAChB,WAAW,CAAC,SAAS,CAAC,KAAK,CAAC;AAC5B,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;GAqBG;AACH,oCAHC,WAAA;IAKD;;OAEG;IACH,YAJG,IAAiB;QAAO,MAAA,IAAA,CAAA,CAAA;IAAA,CAAA;IAK3B;;OAEG;IACH,QANG,KAAoB,MAAA,CAAO,kBAAA,IAAmB,CAAI,KAAC,EAAK,CAAE,CAAC,CAAA;AAO9D,CAAC;AAED;IACA,gBAAgB;IAChB,cAAc,CAAC,SAAS,CAAC,4CAA4C,CAAC;AACtE,CAAC","file":"injection_token.js","sourceRoot":"","sourcesContent":["\n/**\n * Creates a token that can be used in a DI Provider.\n * \n * ### Example ([live demo](http://plnkr.co/edit/Ys9ezXpj2Mnoy3Uc8KBp?p=preview))\n * \n * ```typescript\n * var t = new OpaqueToken(\"value\");\n * \n * var injector = Injector.resolveAndCreate([\n *   {provide: t, useValue: \"bindingValue\"}\n * ]);\n * \n * expect(injector.get(t)).toEqual(\"bindingValue\");\n * ```\n * \n * Using an `OpaqueToken` is preferable to using strings as tokens because of possible collisions\n * caused by multiple providers using the same string as two different tokens.\n * \n * Using an `OpaqueToken` is preferable to using an `Object` as tokens because it provides better\n * error messages.\n * @deprecated since v4.0.0 because it does not support type information, use `InjectionToken<?>`\n * instead.\n */\nexport class OpaqueToken {\n/**\n * @param {?} _desc\n */\nconstructor(protected _desc: string) {}\n/**\n * @return {?}\n */\ntoString(): string { return `Token ${this._desc}`; }\n}\n\nfunction OpaqueToken_tsickle_Closure_declarations() {\n/** @type {?} */\nOpaqueToken.prototype._desc;\n}\n\n/**\n * Creates a token that can be used in a DI Provider.\n * \n * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a\n * runtime representation) such as when injecting an interface, callable type, array or\n * parametrized type.\n * \n * `InjectionToken` is parametrize on `T` which is the type of object which will be returned by the\n * `Injector`. This provides additional level of type safety.\n * \n * ```\n * interface MyInterface {...}\n * var myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));\n * // myInterface is inferred to be MyInterface.\n * ```\n * \n * ### Example\n * \n * {\\@example core/di/ts/injector_spec.ts region='Injector'}\n * \n * \\@stable\n */\nexport class InjectionToken<T> extends OpaqueToken {\nprivate _differentiate_from_OpaqueToken_structurally: any;\n/**\n * @param {?} desc\n */\nconstructor(desc: string) { super(desc); }\n/**\n * @return {?}\n */\ntoString(): string { return `InjectionToken ${this._desc}`; }\n}\n\nfunction InjectionToken_tsickle_Closure_declarations() {\n/** @type {?} */\nInjectionToken.prototype._differentiate_from_OpaqueToken_structurally;\n}\n\n"]}